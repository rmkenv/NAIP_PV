<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Solar Panel Detector</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
<style>
  /* (Same CSS as previous with minor control and visualization settings) */
  #map { height: 520px; margin: 10px 0; }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; align-items: center; }
  .controls label { font-size: 14px; }
  .hint { color: #444; font-size: 13px; margin-bottom: 8px; }
  #result_panel { display: grid; grid-template-columns: 360px 1fr; gap: 10px; }
  #result_panel > div { overflow: auto; }
  #result_panel > div:nth-child(1) img { max-width: 100%; border: 1px solid #ddd; border-radius: 6px; display: none;}
  #result_panel > div:nth-child(2) { height: 520px; }
  #result_panel #result_map { width: 100%; height: 100%; display: none; }
  .badge { background-color: #eef; border-radius: 14px; padding: 2px 6px; margin-left: 6px; font-size: 12px; color: #334; }
  #detections_table { width: 100%; border-collapse: collapse; font-size: 13px; }
  #detections_table th, #detections_table td { border: 1px solid #ccc; padding: 4px 8px; text-align: center; }
  #detections_table th { background-color: #f0f0f0; }
  #detections_table_container { margin-top: 10px; max-height: 180px; overflow-y: auto; display: none; }
</style>
</head>
<body>

<h3>Solar Panel Detector: Draw a box (max 100 km²) and detect solar panels</h3>

<div id="map"></div>

<div class="controls">
  <label>Basemap:
    <select id="basemap">
      <option value="hybrid" selected>ESRI Hybrid</option>
      <option value="osm">OpenStreetMap</option>
    </select>
  </label>
  <label>Imagery source:
    <select id="use_source">
      <option value="naip" selected>NAIP</option>
      <option value="md">Maryland Six Inch</option>
      <option value="usda">USDA</option>
    </select>
  </label>
  <label>Width (px):
    <input type="number" id="width_px" value="2048" min="256" max="3500" />
  </label>
  <label>Image Size:
    <input type="number" id="imgsz" value="1536" min="640" max="2048" step="32" />
  </label>
  <label>Confidence:
    <input type="number" id="conf" step="0.01" min="0" max="1" value="0.15" />
  </label>
  <label>IoU:
    <input type="number" id="iou" step="0.05" min="0" max="1" value="0.45" />
  </label>
  <label><input type="checkbox" id="augment" /> Augment (TTA)</label>
  <label><input type="checkbox" id="sharpen" /> Sharpen</label>
  <button id="preset_high_recall">High Recall</button>
  <button id="run_btn" disabled>Run Detection</button>
</div>

<div id="status" class="hint"></div>

<div id="result_panel">
  <div>
    <img id="result_img" alt="Detection Result" />
  </div>
  <div>
    <div id="result_map"></div>
    <div id="detections_table_container">
      <h4>Detections</h4>
      <table id="detections_table">
        <thead>
          <tr><th>#</th><th>Confidence</th><th>Latitude</th><th>Longitude</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
  // Map Setup
  const map = L.map('map').setView([39.5, -98.35], 4);

  // Layers
  const esriImagery = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri'
  });

  const esriLabels = L.tileLayer('https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Labels/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Labels © Esri'
  });

  const hybrid = L.layerGroup([esriImagery, esriLabels]);
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '© OpenStreetMap'
  });

  hybrid.addTo(map);

  // Maryland coverage polygon (approximate)
  const mdBounds = [[37.9, -79.5], [39.8, -75.0]];
  const mdCoverage = L.rectangle(mdBounds, {
    color: 'blue',
    weight: 2,
    fillOpacity: 0.15,
    dashArray: '4'
  }).addTo(map).bindTooltip("Maryland Six Inch Imagery Coverage");

  // Layers control state
  function setBaseLayer(layerName) {
    map.eachLayer(layer => {
      if(layer !== mdCoverage && !layer._controlPos){ // Keep coverage polygon
        map.removeLayer(layer);
      }
    });
    if (layerName === 'hybrid') {
      hybrid.addTo(map);
    } else {
      osm.addTo(map);
    }
  }

  document.getElementById('basemap').addEventListener('change', e => {
    setBaseLayer(e.target.value);
  });

  // Drawing controls
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    draw: {
      polygon: false,
      polyline: false,
      circle: false,
      marker: false,
      circlemarker: false,
      rectangle: {
        shapeOptions: { color: '#f97316', weight: 2 }
      }
    },
    edit: {
      featureGroup: drawnItems,
      edit: true,
      remove: true
    }
  });
  map.addControl(drawControl);

  // Bounding box constraints and Maryland coverage check
  function calculateBBoxAreaKm2(bounds){
    const rad = deg => deg * (Math.PI / 180);
    const lat1 = bounds.getSouth(), lat2 = bounds.getNorth();
    const lon1 = bounds.getWest(), lon2 = bounds.getEast();
    const latRad = rad((lat1 + lat2)/2);
    const mPerLat = 111132.92 - 559.82 * Math.cos(2*latRad) + 1.175*Math.cos(4*latRad) - 0.0023*Math.cos(6*latRad);
    const mPerLon = 111412.84 * Math.cos(latRad) - 93.5*Math.cos(3*latRad) + 0.118*Math.cos(5*latRad);
    const width_m = Math.abs(lon2 - lon1)*mPerLon;
    const height_m = Math.abs(lat2 - lat1)*mPerLat;
    return (width_m*height_m)/1e6;
  }

  function isBoundingBoxWithinMD(bounds) {
    const mdLatLngBounds = L.latLngBounds(mdBounds);
    return mdLatLngBounds.intersects(bounds);
  }

  let lastRect = null;

  function validateDrawnBox(layer) {
    if(!layer) return false;
    const bounds = layer.getBounds();
    const area = calculateBBoxAreaKm2(bounds);
    if (area < 0.5 || area > 100) {
      alert(`Selected area is ${area.toFixed(2)} km². Must be between 0.5 and 100 km².`);
      return false;
    }
    if(document.getElementById('use_source').value === 'md') {
      if(!isBoundingBoxWithinMD(bounds)) {
        alert("Selected area is outside Maryland Six Inch imagery coverage.");
        return false;
      }
    }
    return true;
  }

  map.on('draw:created', e => {
    if(!validateDrawnBox(e.layer)) return;
    drawnItems.clearLayers();
    lastRect = e.layer;
    drawnItems.addLayer(lastRect);
    document.getElementById('run_btn').disabled = false;
  });

  map.on('draw:edited', e => {
    const layers = e.layers.getLayers();
    if(layers.length && validateDrawnBox(layers[0])) {
      lastRect = layers[0];
    } else {
      document.getElementById('run_btn').disabled = true;
    }
  });

  map.on('draw:deleted', e => {
    drawnItems.clearLayers();
    lastRect = null;
    document.getElementById('run_btn').disabled = true;
  });

  // Inference request
  async function runInference(bounds, params) {
    const fd = new FormData();
    fd.append('min_lon', bounds.getWest());
    fd.append('min_lat', bounds.getSouth());
    fd.append('max_lon', bounds.getEast());
    fd.append('max_lat', bounds.getNorth());
    fd.append('width_px', params.width_px);
    fd.append('use_source', params.use_source);
    fd.append('conf', params.conf);
    fd.append('iou', params.iou);
    fd.append('imgsz', params.imgsz);
    fd.append('augment', params.augment);
    fd.append('sharpen', params.sharpen);

    const resp = await fetch('/infer_imagery', { method: 'POST', body: fd });
    if (!resp.ok) throw new Error(await resp.text());
    return await resp.json();
  }

  // Show detection overlays on map
  function showDetectionsOnMap(data, bounds) {
    const mapDiv = document.getElementById('result_map');
    mapDiv.style.display = 'block';
    if(window.resultMap) window.resultMap.remove();

    window.resultMap = L.map('result_map', { zoomControl: true, attributionControl: false });

    const imageBounds = L.latLngBounds(bounds.getSouthWest(), bounds.getNorthEast());

    const imagery = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri'
    });
    const labels = L.tileLayer('https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Labels/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Labels © Esri'
    });

    imagery.addTo(window.resultMap);
    labels.addTo(window.resultMap);

    // Image overlay with detection results
    L.imageOverlay(data.image_data_url, imageBounds).addTo(window.resultMap);
    window.resultMap.fitBounds(imageBounds);
  }

  // Populate detections table
  function populateDetectionsTable(detections) {
    const container = document.getElementById('detections_table_container');
    const tbody = document.querySelector('#detections_table tbody');
    tbody.innerHTML = '';
    if(!detections || detections.length === 0) {
      container.style.display = 'none';
      return;
    }
    container.style.display = 'block';
    detections.forEach((det, i) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${i + 1}</td>
        <td>${(det.score * 100).toFixed(1)}%</td>
        <td>${det.lat.toFixed(6)}</td>
        <td>${det.lon.toFixed(6)}</td>
      `.trim();
      tbody.appendChild(tr);
    });
  }

  // Preset button fills recommended parameters for high recall
  document.getElementById('preset_high_recall').addEventListener('click', () => {
    document.getElementById('width_px').value = 2048;
    document.getElementById('imgsz').value = 1536;
    document.getElementById('conf').value = 0.15;
    document.getElementById('iou').value = 0.45;
    document.getElementById('augment').checked = true;
    document.getElementById('sharpen').checked = true;
  });

  // Run detection button event
  document.getElementById('run_btn').addEventListener('click', async () => {
    const status = document.getElementById('status');
    const imgEl = document.getElementById('result_img');
    const mapEl = document.getElementById('result_map');

    if(!lastRect) {
      alert("Please draw a bounding box before running detection.");
      return;
    }

    const bounds = lastRect.getBounds();
    const params = {
      width_px: Number(document.getElementById('width_px').value),
      use_source: document.getElementById('use_source').value,
      conf: Number(document.getElementById('conf').value),
      iou: Number(document.getElementById('iou').value),
      imgsz: Number(document.getElementById('imgsz').value),
      augment: document.getElementById('augment').checked,
      sharpen: document.getElementById('sharpen').checked,
    };

    status.textContent = 'Fetching imagery and running detection...';
    imgEl.style.display = 'none';
    mapEl.style.display = 'none';
    mapEl.innerHTML = '';
    populateDetectionsTable([]);

    try {
      const data = await runInference(bounds, params);
      if(data.error) throw new Error(data.error);

      imgEl.src = data.image_data_url;
      imgEl.style.display = 'block';

      showDetectionsOnMap(data, bounds);

      status.textContent = `Detected ${data.count} panels | Area: ${
        data.area ? data.area + ' m²' : 'N/A'
      } | Resolution: ${data.mpp_x ? data.mpp_x.toFixed(3) : '?'}m x ${data.mpp_y ? data.mpp_y.toFixed(3) : '?'}m | Augment: ${params.augment} | Sharpen: ${params.sharpen} | Source: ${data.imagery_source}`;

      populateDetectionsTable(data.detections);
    } catch (err) {
      status.textContent = 'Error: ' + err.message;
      console.error(err);
    }
  });
</script>
